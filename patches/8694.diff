diff --git a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/debugging/NbProtocolServer.java b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/debugging/NbProtocolServer.java
index 6fe9ece2c0cb..82f5346568d1 100644
--- a/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/debugging/NbProtocolServer.java
+++ b/java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/debugging/NbProtocolServer.java
@@ -81,7 +81,9 @@
 import org.netbeans.api.debugger.jpda.JPDADebugger;
 import org.netbeans.api.debugger.jpda.ObjectVariable;
 import org.netbeans.api.debugger.jpda.Variable;
+import org.netbeans.api.project.Project;
 import org.netbeans.modules.debugger.jpda.truffle.vars.TruffleVariable;
+import org.netbeans.modules.java.lsp.server.LspServerState;
 import org.netbeans.modules.java.lsp.server.LspSession;
 import org.netbeans.modules.java.lsp.server.URITranslator;
 import org.netbeans.modules.java.lsp.server.debugging.breakpoints.NbBreakpointsRequestHandler;
@@ -165,6 +167,20 @@ public CompletableFuture<Capabilities> initialize(InitializeRequestArguments arg
         caught.setLabel("Caught Exceptions");
         caps.setExceptionBreakpointFilters(new ExceptionBreakpointsFilter[]{uncaught, caught});
         caps.setSupportsExceptionInfoRequest(true);
+        
+        LspServerState lspServerState = context.getLspSession().getLookup().lookup(LspServerState.class);
+        if (lspServerState != null) {
+            CompletableFuture<Project[]> initDone = lspServerState.openedProjects();
+            if (!initDone.isDone()) {
+                LOGGER.log(Level.INFO, "Waiting on LS protocol server {0} to finish initialization", lspServerState);
+                return lspServerState.openedProjects().thenApply(prjs -> {
+                    LOGGER.log(Level.FINE, "LS protocol server {0} initialized, DAP init complete", lspServerState);
+                    return caps;
+                });
+            } else {
+                LOGGER.log(Level.FINE, "LS protocol server {0} ready", lspServerState);
+            }
+        }
         return CompletableFuture.completedFuture(caps);
     }
 
diff --git a/java/maven/src/org/netbeans/modules/maven/execute/MavenCommandLineExecutor.java b/java/maven/src/org/netbeans/modules/maven/execute/MavenCommandLineExecutor.java
index 81a7feb329f2..c1d60f9c4b71 100644
--- a/java/maven/src/org/netbeans/modules/maven/execute/MavenCommandLineExecutor.java
+++ b/java/maven/src/org/netbeans/modules/maven/execute/MavenCommandLineExecutor.java
@@ -37,6 +37,7 @@
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -128,6 +129,12 @@ public class MavenCommandLineExecutor extends AbstractMavenExecutor {
     private String processUUID;
     private Process preProcess;
     private String preProcessUUID;
+
+    /**
+     * Diagnostics: stracktrace that shows what code requested the execution.
+     */
+    private final Throwable trace;
+    
     private static final SpecificationVersion VER18 = new SpecificationVersion("1.8"); //NOI18N
     private static final Logger LOGGER = Logger.getLogger(MavenCommandLineExecutor.class.getName());
 
@@ -191,6 +198,11 @@ public ExecutorTask execute(RunConfig config, InputOutput io, TabContext tc) {
     public MavenCommandLineExecutor(RunConfig conf, InputOutput io, TabContext tc) {
         super(conf, tc);
         this.io = io;
+        if (LOGGER.isLoggable(Level.FINER)) {
+            this.trace = new Throwable();
+        } else {
+            this.trace = null;
+        }
     }
 
     /**
@@ -331,6 +343,8 @@ public void actionPerformed(ActionEvent e) {
 //                ioput.getOut().println(key + ":" + env.get(key));
 //            }
             ProcessBuilder builder = constructBuilder(clonedConfig, ioput);
+            LOGGER.log(Level.FINER, "Executing process {0} from {1}", new Object[] { builder.command(), this });
+            LOGGER.log(Level.FINER, "Origin:", this.trace);
             printCoSWarning(clonedConfig, ioput);
             processUUID = UUID.randomUUID().toString();
             builder.environment().put(KEY_UUID, processUUID);
@@ -348,6 +362,7 @@ public void actionPerformed(ActionEvent e) {
             throw death;
         } finally {
             BuildExecutionSupport.registerFinishedItem(item);
+            LOGGER.log(Level.FINER, "Execution of {0} terminated", this );
 
             try { //defend against badly written extensions..
                 out.buildFinished();
